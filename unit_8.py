'''
23.8. XPATHs tricks

Применять различные хитрости XPath нужно тогда, когда у нас много элементов и сложная структура страницы. Поэтому в
этом уроке мы будем пробовать наши трюки на сложном сайте AWS.

Обращение к элементам меню и подменю на сайте
Частая задача в автоматизации — проверить наличие элементов меню и правильность ссылок в меню.

К этому элементу можно написать несколько вариантов локаторов.

Вариант 1:  //div[@class="m-nav-primary-links"]/ul/li[1]/a
Здесь мы включили индекс элемента. Такой способ будет работать, пока не поменяется порядок элементов в меню.
Вариант 2, без индекса:
Мы можем избежать использования индекса, указав локатор по атрибутам элемента: //a[@data-panel="m-nav-panel-products"].
К счастью, атрибут data-panel уникален и указывает только на этот элемент. Другой атрибут, который мы можем использовать
— href: //a[@href="/products/?nc2=h_ql_prod"].
Трюк №1: получение значения атрибутов
Часто в тестировании стоит задача убедиться, что определенный элемент имеет ожидаемые атрибуты — ссылка указывает на
правильный раздел сайта, картинка содержит правильный источник. Тогда мы можем получить значение атрибутов.

Выполните самостоятельно:

Откройте сайт AWS.
Откройте Console.
Введите $x('//a[@data-panel="m-nav-panel-products"]/@href') и нажмите Enter.
Так вы получите атрибут href у первого элемента меню. Значение видно в раскрывающемся списке, в пункте nodeValue:
Часто нужно также получить текст внутри тега. Это делается через специальный атрибут /text():

Задание 23.8.1
1/1 point (graded)
Напишите XPath для получения атрибута ссылки у второго элемента меню (Solutions), написав локатор через атрибут data-panel.

$x('//a[@data-panel="m-nav-panel-solutions"]/@href')

Трюк №2: поиск по содержимому в атрибутах и тексте
Если возникает необходимость найти один тег (или несколько тегов)  с определенным текстом, это тоже можно делать через
XPath. Для того используется служебный указатель contains, который получает два параметра: в каком атрибуте искать и
что искать (после запятой).

Пример 1: $x('//a[contains(text(), "Products")]')
Находит все теги ссылок, внутри которых есть текст "Products".

Пример 2: $x('//div[contains(@class, "m-nav-panel")]')
Находит все div у которых в имени класса есть строчка "m-nav-panel".

Пример 3: $x('//img[contains(@src, ".png")]')
Находит все png-картинки.

Трюк №3: Поиск по нескольким атрибутам
Бывает, что нам надо проверить элемент, но у него нет уникальных атрибутов. Тогда мы можем строить локатор от какого-то
уникального элемента или указать на несколько атрибутов и отсеять лишнее.

Рассмотрим пример: надо указать на блок с текстами.
$x('//div[@class="lb-xb-grid-wrap"]') — локатор по классу указывает на 36 элементов,

$x('//div[@class="lb-xb-grid-wrap" and @style="margin-bottom:30px;"]') — локатор по классу и стилю, указывает на 7
элементов.

Чтобы написать локатор по нескольким атрибутам, используется слово and, значок атрибута @ и значение атрибута. При
помощи слова or мы можем найти все элементы, у которых присутствует хотя бы один атрибут из указанных:
$x('//div[@class="lb-xb-grid-wrap" or @style="margin-bottom:30px;"]') — локатор указывает на 62 элемента.

Задание 23.8.2
1/1 point (graded)
Напишите XPath который укажет на все атрибуты данного тега:
 <div class="lb-tabs lb-tabs-minimal-text-dark-bg" style="background-color:#232f3e;" data-lb-comp="tabs" data-lb-comp-registered="true">

$x('//div[@class="lb-tabs lb-tabs-minimal-text-dark-bg" and @style="background-color:#232f3e;" and @data-lb-comp="tabs" and @data-lb-comp-registered="true"]')

Трюк №4: Вниз и вверх по DOM
Иногда к элементу весьма непросто добраться. К примеру, ссылка Learn More под картой Global Network of AWS Regions.

Конечно, мы можем написать локатор по классу, атрибуту href или тексту внутри элемента. Но в данном случае также можно
применить уникальную возможность, которая есть только в XPath — подъем к родителям по DOM.

Сначала укажем div , который содержит карту: $x('//div[@data-lb-comp="gi-map"]'. Затем мы можем указать последовательно
всех предков до желаемой ссылки, и также можем сократить путь ещё раз, использовав двойной прямой слеш. Тем самым мы
указываем, что тег после двойного следует искать в любом месте внутри тега-родителя с атрибутом data-lb-comp="gi-map".

$x('//div[@data-lb-comp="gi-map"]//a') — такой XPath указывает на 5 элементов.

Но внутри ссылки Learn More есть еще тег <i>. Если мы укажем его, то получим локатор, указывающий на один
элемент://div[@data-lb-comp="gi-map"]//a/i. Но ведь мы изначально хотели получить локатор для ссылки. Теперь мы можем
сделать это, просто вернувшись наверх по DOM-дереву при помощи команды .. (две точки подряд):
$x('//div[@data-lb-comp="gi-map"]//a/i/..').

Как видим, теперь наш локатор указывает только на один элемент. Такой ход может пригодиться, если дочерний элемент
имеет ID или другой набор уникальных атрибутов, а нам для тестов нужен его родительский элемент, который такой
уникальности не имеет.

Подведём итоги
Вы освоили многие дополнительные свойства для написания коротких и надежных локаторов XPath. Осталось закрепить всю
полученную информацию в ходе практической работы.




















'''